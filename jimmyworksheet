import dash
from dash import dcc, html, Output, Input, State
import requests
import json

app = dash.Dash(__name__)

API_KEY = '' 
 # 換你的 Google Maps API Key

app.layout = html.Div([
    dcc.Input(id='address', type='text', placeholder='輸入地址...', style={'fontSize': 20}),
    dcc.Input(id='budget', type='number', placeholder='預算上限', style={'fontSize': 20}),
    html.Button('查詢', id='search-btn', style={'fontSize': 20}),
    html.Div(id='result', style={'fontSize': 20}),
    dcc.Checklist(id='place-selector', options=[], value=[]),
    dcc.Store(id='all-place-details', data={}),
    html.Div(id='budget-warning', style={'color': 'red', 'marginTop': '20px', 'fontSize': 20}),
], style={'fontSize': 60})

def get_latlng(address, apikey):
    resp = requests.get(
        'https://maps.googleapis.com/maps/api/geocode/json',
        params={'address': address, 'key': apikey}
    ).json()
    loc = resp['results'][0]['geometry']['location']
    return loc['lat'], loc['lng']

def search_places(lat, lng, apikey, radius=1000):
    place_types = 'restaurant|cafe|bar|tourist_attraction'
    resp = requests.get(
        'https://maps.googleapis.com/maps/api/place/nearbysearch/json',
        params = {
            'location': f'{lat},{lng}',
            'radius': radius,
            'type': place_types, # 多種類型用 | 串起來
            'key': apikey
        }
    ).json()
    print('Nearby API response:', resp)  
    return resp.get('results', [])   #取出'results'，'results' 不存在，函式會回傳一個空的列表（[]）


def price_level_by_budget(budget):
    if budget is None:
        return 4
    if budget <= 200:
        return 1
    elif budget <= 500:
        return 2
    elif budget <= 1000:
        return 3
    else:
        return 4


#判斷「餐廳的最低價格」是否在使用者的預算以內。
def within_budget(price_range, budget):
    if not price_range or budget is None:
        return False
    try:
        price_range = price_range.replace('$', '')
        start_str, end_str = price_range.split('-')
        start, end = float(start_str.strip()), float(end_str.strip())
        return start <= budget
    except Exception:
        return False


def calculate_distance(lat1, lng1, lat2, lng2):
    """計算兩點之間的距離（公里）"""
    from math import radians, sin, cos, sqrt, atan2
    R = 6371  # 地球半徑（公里）
    lat1, lng1, lat2, lng2 = map(radians, [lat1, lng1, lat2, lng2])
    dlat = lat2 - lat1
    dlng = lng2 - lng1
    a = sin(dlat / 2) ** 2 + cos(lat1) * cos(lat2) * sin(dlng / 2) ** 2
    c = 2 * atan2(sqrt(a), sqrt(1 - a))
    return R * c


def normalize_score(value, min_val, max_val):
    """將數值標準化到 0-1 範圍（越小越好）"""
    if max_val == min_val:
        return 0
    return 1 - (value - min_val) / (max_val - min_val)


def calculate_weighted_score(places_list, user_lat, user_lng, budget, distance_weight=0.5, price_weight=0.5):
    """
    計算加權推薦分數
    distance_weight: 距離的權重（預設 50%）
    price_weight: 價格的權重（預設 50%）
    """
    if not places_list:
        return []
    
    # 計算每個地點的距離和價格分數
    for place in places_list:
        lat = place.get('geometry', {}).get('location', {}).get('lat')
        lng = place.get('geometry', {}).get('location', {}).get('lng')
        
        if lat and lng:
            distance = calculate_distance(user_lat, user_lng, lat, lng)
            place['distance_km'] = distance
        else:
            place['distance_km'] = float('inf')
        
        # 提取價格資訊
        price_level = place.get('price_level')
        try:
            price_level = int(price_level) if price_level is not None else None
        except:
            price_level = None
        place['price_level_int'] = price_level
    
    # 取得距離和價格的最小/最大值用於標準化
    valid_distances = [p['distance_km'] for p in places_list if p['distance_km'] != float('inf')]
    valid_prices = [p['price_level_int'] for p in places_list if p['price_level_int'] is not None]
    
    if not valid_distances:
        valid_distances = [0, 1]
    if not valid_prices:
        valid_prices = [1, 4]
    
    min_distance = min(valid_distances) if valid_distances else 0
    max_distance = max(valid_distances) if valid_distances else 1
    min_price = min(valid_prices) if valid_prices else 1
    max_price = max(valid_prices) if valid_prices else 4
    
    # 計算每個地點的加權分數
    for place in places_list:
        distance = place['distance_km']
        price = place['price_level_int']
        
        # 距離分數（越近越好，標準化到 0-1）
        if distance == float('inf'):
            distance_score = 0
        else:
            distance_score = normalize_score(distance, min_distance, max_distance)
        
        # 價格分數（越便宜越好，標準化到 0-1）
        if price is None:
            price_score = 0.5  # 沒有價格資訊時給予中等分數
        else:
            price_score = normalize_score(price, min_price, max_price)
        
        # 加權總分（0-100 分）
        weighted_score = (distance_score * distance_weight + price_score * price_weight) * 100
        place['weighted_score'] = round(weighted_score, 2)
        place['distance_score'] = round(distance_score * 100, 2)
        place['price_score'] = round(price_score * 100, 2)
    
    # 按加權分數排序（高分優先）
    sorted_places = sorted(places_list, key=lambda x: x['weighted_score'], reverse=True)
    
    return sorted_places

@app.callback(
    Output('result', 'children'),
    Output('all-place-details', 'data'),
    Input('search-btn', 'n_clicks'),
    State('address', 'value'),
    State('budget', 'value'),
)
def suggest(n, address, budget):
    if not address or not budget:
        return '請輸入地址與預算', {}  #第二個值 {} 會傳給 Output('all-place-details', 'data')

    try:
        lat, lng = get_latlng(address, API_KEY)
    except Exception as e:
        return f'地址轉經緯度錯誤: {e}', {}

    nearby = search_places(lat, lng, API_KEY)
    if not nearby:
        return '附近找不到相關店家', {}

    max_price_level = price_level_by_budget(budget)
    
    # 計算加權分數並排序
    nearby_scored = calculate_weighted_score(nearby, lat, lng, budget, distance_weight=0.5, price_weight=0.5)
    
    results = []
    place_details_dict = {}

    for p in nearby_scored:
        place_details_dict[p['place_id']] = p
        pl = p.get('price_level')
        print(f"店名: {p.get('name','未知')}, price_level={pl} ({type(pl)}), 預算等級={max_price_level}, 距離={p.get('distance_km', '未知')}km, 推薦分數={p.get('weighted_score', 0)}")
        try:
            pl_int = int(pl) if pl is not None else None
        except Exception as e:
            print(f"型別轉換失敗: {e}")
            pl_int = None

        if pl_int is not None and pl_int <= max_price_level:
            ann = f"{p.get('name','未知')} - 地址：{p.get('vicinity','無')} - 價位等級 {pl_int} - 評分 {p.get('rating','無')} - 距離 {p.get('distance_km', '未知'):.2f}km - 推薦分數 {p.get('weighted_score', 0)}/100 ⭐"
            results.append({'label': ann, 'value': p['place_id']})
        elif 'price_range' in p and within_budget(p['price_range'], budget):
            ann = f"{p.get('name','未知')} - 地址：{p.get('vicinity','無')} - 價格區間 {p['price_range']} - 評分 {p.get('rating','無')} - 距離 {p.get('distance_km', '未知'):.2f}km - 推薦分數 {p.get('weighted_score', 0)}/100 ⭐"
            results.append({'label': ann, 'value': p['place_id']})

    if not results:
        return '附近有店家，但 "價位等級" 欄位出現型別錯誤或缺值，請檢查API回傳。', {}

    return dcc.Checklist(
        options=results,
        value=[],
        id='place-selector'
    ), place_details_dict

@app.callback(
    Output('budget-warning', 'children'),
    Input('place-selector', 'value'),
    State('budget', 'value'),
    State('all-place-details', 'data')
)
def check_budget(selected_places, budget, all_details):
    if not selected_places or not budget:
        return ''

    total_cost = 0
    for place_id in selected_places:
        detail = all_details.get(place_id, {})
        cost = 0
        pr = detail.get('price_range')
        if pr and '-' in pr:
            try:
                pr_clean = pr.replace('$', '')
                start, end = pr_clean.split('-')
                cost = (float(start.strip()) + float(end.strip())) / 2
            except:
                cost = 0
        else:
            pl = detail.get('price_level')
            try:
                pl_int = int(pl) if pl is not None else None
            except:
                pl_int = None
            if pl_int:
                level_price_map = {1: 100, 2: 300, 3: 600, 4: 1000}
                cost = level_price_map.get(pl_int, 0)
        total_cost += cost

    if total_cost > budget:
        return f'⚠️ 超出預算 {total_cost}，請調整選擇或提高預算！'
    return ''

if __name__ == '__main__':
    app.run(debug=True)
